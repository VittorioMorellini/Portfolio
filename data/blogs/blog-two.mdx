---
title: 'Build a portfolio with Next.js'
publishedAt: '2023-02-18'
description: 'A simple guide to build a personal portfolio'
cover: '/optimized/articles/blog-one/hero.webp'
seoDescription: 'Article of Next.js'
category: 'Next.js'
image: 'https://images.unsplash.com/photo-1654863075380-5fce8cae1851?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHx0b3BpYy1mZWVkfDMyfGJvOGpRS1RhRTBZfHxlbnwwfHx8fA%3D%3D&auto=format&fit=crop&w=500&q=60'
---

## Next.js - The new framework
Next.js is a framework to create full stack application based on React library developed and mantained by Vercel.
Vercel gives the possibility to deploy our Next applications directly on his servers via github in an easy way.

Next.js supports multiple authentication patterns, each designed for different use cases.
One of this is easy and it is based on oidc-client, Open Id connect

## What is a portfolio
A portfolio is a web application that introduces a professionist, presenting the story, the life, the education and the career path taken 
The personal portfolio has to follow some basic rules:

* To Follow modern graphic design 
* To Be Responsive to different devices
* To Contain a blog page where the author can publish his articles 
* To Give the option to the users to interact to the portfolio, by contancting the author, by publishing posts 

## Developing a portfolio
Using Next.js to develop a simply web application is easy and quick.
This framework gives us a quick way to build full stack application and it is easy to manage different kind of rendering in the pages

### SSG - Server Static Generation
Actually in next it is possbile to determinate if a page has to be statically generated by using getStaticProps together with getStaticPaths

```bash
export const getStaticPaths: GetStaticPaths = async () => {
    const paths = await getPostsPaths()
    //console.log({paths})
    return {
        //paths: paths.map(x => `/posts/${x.replace('%3A', '_')}`),
        paths: paths.map(x => `/posts/${normalizeEncodedFileName(x)}`),
        fallback: "blocking",
    }    
}

export const getStaticProps = async ({ params }: { params: { id: string } }) => {
    const idStr: string[] = params.id.split('-');
    const id = idStr[0]
    const aree = await getAreeZeroLevel(null)
    const article = await getPost(parseInt(id))
    const attachments = await getPostAttachments(parseInt(id), true)
    const author = await getAuthor(article?.redactorId) ?? null
    const relatedPosts = await getRelatedPost(10, parseInt(id))
    const historyPosts = await getHistoryPost(10, parseInt(id))
    //const relatedPosts = []
    return {
        props: { article, attachments, author, aree, relatedPosts, historyPosts },
    }
}
```

This feature generates statically all the pages needed by the application at build time.
In this pattern the SEO is clearely optimized and the google agent can quicly find all the content needed.

### ISR - Incremental static regeneration 
It is important to notice the option revalidate

```bash
    const relatedPosts = await getRelatedPost(10, parseInt(id))
    const historyPosts = await getHistoryPost(10, parseInt(id))
    //const relatedPosts = []
    return {
        props: { article, attachments, author, aree, relatedPosts, historyPosts },
        revalidate: 3600
    }
}
```
Magically it gives the possibility to the server to dinamically ri-generate the page and updates so the content every established time.
The duration is expressed in secodn, 3600 in the example

### SSR - Server side rendering
Using the function: getServerSide() it is possible to generate the page server side, but at request time.

```bash
export async function getServerSideProps(context: any) {
    //console.log('I am in server side props loading SSR')
    const data = await fetch(server + `/api/article/${context.query.id}`)
    const result: Article = await data.json();

    return {
      props: { article: result }
    }
}
```

With this pattern the page is generated server side dinamically, completely dinamically.
The data are fetched at run time when the page is requested.

In the same application it is possible to miscellaneus different pattern and use the better related to the user necessity and to the real optimization for the application